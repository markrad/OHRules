'use strict';

var util = require('util');

var ohItem = require('../ohItem');

var rule = function(type)
{
    var myType = type;
    var that = this;

    this._localFunc = function()
    {
        return 'base class localFunc';
    }

    this.toString = () => { return 'rule'; }

    this.tester = function()
    {
        console.log('In base class: ' + this._localFunc());
    }

    this.picker = function()
    {
        this.tester();
    }

	this.__defineGetter__('type', () => { return myType; });
}

var rule1 = function()
{
    rule1.super_.call(this, 'rule1');
    var that = this;

    this._localFunc = function()
    {
        return 'rule1 localFunc';
    }

    this.init = function(arg)
    {
        console.log('Init rule1:' + arg);
    }

    this.toString = () => { return 'rule1'; }
};

util.inherits(rule1, rule);

var rule2 = function()
{
    rule.call(this, 'rule2');
    this.getThat = () => { return that; }
    var that = this;

    this.init = function(arg)
    {
        console.log('Init rule2:' + arg);
    }

    this.tester = function()
    {
        console.log('In rule2 class');
    }
}

util.inherits(rule2, rule);

var testCascade = function()
{
    var children = Array.prototype.slice.call(arguments);

    console.log('rule1=' + children[0].toString());
    console.log('rule2=' + children[1].toString());
    console.log('rule1=' + children[0].type);
    console.log('rule2=' + children[1].type);

    children[0].tester();
    children[1].tester();
    children[0].picker();
    children[1].picker();
	
    var that = this;
	
	this.init = function(arg)
	{
        for (var rule of children)
        {
            rule.init(arg);
        }
	}
}

module.exports = new testCascade(new rule1(), new rule2());